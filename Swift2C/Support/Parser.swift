/*-------------------------------------------------------------------------
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
    Swift port by Michael Griebling, 2015-2017

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

    NOTE: The code below has been automatically generated from the
    Parser.frame, Scanner.frame and taste.atg files.  DO NOT EDIT HERE.
-------------------------------------------------------------------------*/

import Foundation



public class Parser {
	public let _EOF = 0
	public let _ident = 1
	public let _hexNumber = 2
	public let _decNumber = 3
	public let _octalInt = 4
	public let _hexInt = 5
	public let _binInt = 6
	public let _decInt = 7
	public let _string = 8
	public let _char = 9
	public let _class = 10
	public let _func = 14
	public let _Int = 17
	public let _Bool = 18
	public let _Double = 19
	public let _String = 20
	public let _Character = 21
	public let _Any = 22
	public let _var = 23
	public let _let = 24
	public let _if = 26
	public let _else = 27
	public let _while = 28
	public let _repeat = 29
	public let _case = 30
	public let _default = 31
	public let _switch = 32
	public let _true = 34
	public let _false = 35
	public let maxT = 50

	static let _T = true
	static let _x = false
	static let minErrDist = 2
	let minErrDist : Int = Parser.minErrDist

	public var scanner: Scanner
	public var errors: Errors

	public var t: Token             // last recognized token
	public var la: Token            // lookahead token
	var errDist = Parser.minErrDist

	public var tab : SymbolTable!
	public var gen : CodeGenerator!
	
	func evalConstants(_ obj: Obj, _ op: Op, _ obj2: Obj) -> Obj {
	    if obj.kind == .constant && obj2.kind == .constant {
	        return tab.BinExpr(obj, op, obj2)
	    } else {
	        gen.Emit(obj, op, obj2); return obj
	    }
	}
	
	func evalConstants(_ op: Op, _ obj: Obj) -> Obj {
	    if obj.kind == .constant {
	        return tab.UnaryExpr(op, obj)
	    } else {
	        gen.Emit(op, obj); return obj
	    }
	}
	
	/*--------------------------------------------------------------------------*/
	
	


    public init(scanner: Scanner) {
        self.scanner = scanner
        errors = Errors()
        t = Token()
        la = t
    }
    
    func SynErr (_ n: Int) {
        if errDist >= minErrDist { errors.SynErr(la.line, col: la.col, n: n) }
        errDist = 0
    }
    
    public func SemErr (_ msg: String) {
        if errDist >= minErrDist { errors.SemErr(t.line, col: t.col, s: msg) }
        errDist = 0
    }

	func Get () {
		while true {
            t = la
            la = scanner.Scan()
            if la.kind <= maxT { errDist += 1; break }

			la = t
		}
	}
	
    func Expect (_ n: Int) {
        if la.kind == n { Get() } else { SynErr(n) }
    }
    
    func StartOf (_ s: Int) -> Bool {
        return set(s, la.kind)
    }
    
    func ExpectWeak (_ n: Int, _ follow: Int) {
        if la.kind == n {
			Get()
		} else {
            SynErr(n)
            while !StartOf(follow) { Get() }
        }
    }
    
    func WeakSeparator(_ n: Int, _ syFol: Int, _ repFol: Int) -> Bool {
        var kind = la.kind
        if kind == n { Get(); return true }
        else if StartOf(repFol) { return false }
        else {
            SynErr(n)
            while !(set(syFol, kind) || set(repFol, kind) || set(0, kind)) {
                Get()
                kind = la.kind
            }
            return StartOf(syFol)
        }
    }

	func Swift2C() {
		var name = "" 
		Expect(_class)
		Expect(_ident)
		name = t.val; tab.OpenScope(name); gen.Emit("#include \"\(name).h\""); gen.Ln() 
		Expect(11 /* "{" */)
		while la.kind == _func || la.kind == _var || la.kind == _let {
			if la.kind == _var || la.kind == _let {
				VarDecl()
				gen.Ln() 
				if la.kind == 12 /* ";" */ {
					Get()
				}
			} else {
				ProcDecl()
				gen.Ln() 
			}
		}
		Expect(13 /* "}" */)
		tab.CloseScope(); gen.Ln()
		/* if gen.progStart == -1 { SemErr("main function never defined") } */
		
	}

	func VarDecl() {
		var obj: Obj! = nil; var name = ""; var type = OType.undef; var kind = OKind.variable 
		if la.kind == _var {
			Get()
		} else if la.kind == _let {
			Get()
			kind = .constant; gen.Emit("const ") 
		} else { SynErr(51) }
		Expect(_ident)
		name = t.val 
		Expect(25 /* ":" */)
		Type(&type)
		obj = tab.NewObj(name, kind, type)
		gen.Emit(type: obj.type); gen.Emit(obj); gen.Emit(";"); gen.Ln() 
	}

	func ProcDecl() {
		var name = ""; var mod = "" 
		Expect(_func)
		Expect(_ident)
		name = t.val; _ = tab.NewObj(name, .proc, .undef)
		if name == "Main" { /* TBD */ }
		mod = tab.topScope?.name ?? ""
		tab.OpenScope(name)
		gen.Emit("func \(mod)_\(name)")
		Expect(15 /* "(" */)
		Expect(16 /* ")" */)
		gen.Emit("()") 
		CodeBlock()
		
	}

	func CodeBlock() {
		Expect(11 /* "{" */)
		gen.Emit(" {"); gen.Ln() 
		Statements()
		Expect(13 /* "}" */)
		gen.Emit("}"); gen.Ln() 
	}

	func Type(_ type: inout OType) {
		type = .undef 
		switch la.kind {
		case _Int: 
			Get()
			type = .integer(0) 
		case _Bool: 
			Get()
			type = .boolean(false) 
		case _Double: 
			Get()
			type = .double(0) 
		case _String: 
			Get()
			type = .string("") 
		case _Character: 
			Get()
			type = .character("\0") 
		case _Any: 
			Get()
			type = .any(0) 
		default: SynErr(52)
		}
	}

	func IfStat() {
		var obj: Obj! = nil 
		Expect(_if)
		gen.Emit("if (") 
		Expr(&obj)
		gen.Emit(")") 
		CodeBlock()
		while la.kind == _else {
			Get()
			if la.kind == _if {
				Get()
				gen.Emit("else if (") 
				Expr(&obj)
				gen.Emit(")") 
				CodeBlock()
			} else if la.kind == 11 /* "{" */ {
				gen.Emit("else") 
				CodeBlock()
			} else { SynErr(53) }
		}
	}

	func Expr(_ obj: inout Obj!) {
		var obj2: Obj! = nil; var op = Op.UNDEF 
		SimExpr(&obj)
		if StartOf(1) {
			RelOp(&op)
			SimExpr(&obj2)
			obj = evalConstants(obj, op, obj2) 
		}
	}

	func WhileStat() {
		var obj: Obj! = nil 
		Expect(_while)
		gen.Emit("while (") 
		Expr(&obj)
		gen.Emit(")") 
		CodeBlock()
	}

	func RepeatStat() {
		var obj: Obj! = nil 
		Expect(_repeat)
		gen.Emit("do") 
		CodeBlock()
		Expect(_while)
		gen.Emit("while (") 
		Expr(&obj)
		gen.Emit(")") 
	}

	func Pattern() {
		var obj: Obj! = nil 
		Expr(&obj)
	}

	func CaseLabel() {
		if la.kind == _case {
			Get()
			gen.Emit("case") 
			Pattern()
		} else if la.kind == _default {
			Get()
			gen.Emit("default") 
		} else { SynErr(54) }
		Expect(25 /* ":" */)
		gen.Emit(":") 
	}

	func SwitchCase() {
		CaseLabel()
		Statements()
	}

	func Statements() {
		while StartOf(2) {
			Stat()
			if la.kind == 12 /* ";" */ {
				Get()
			}
		}
	}

	func SwitchStat() {
		var obj : Obj? = nil 
		Expect(_switch)
		gen.Emit("switch") 
		Expr(&obj)
		Expect(11 /* "{" */)
		gen.Emit(" {") 
		while la.kind == _case || la.kind == _default {
			SwitchCase()
		}
		Expect(13 /* "}" */)
		gen.Emit("}") 
	}

	func Stat() {
		var obj2 : Obj!; var obj: Obj! 
		switch la.kind {
		case _ident: 
			Get()
			obj = tab.Find(t.val); gen.Emit(obj) 
			if la.kind == 33 /* "=" */ {
				Get()
				if obj.kind != .variable { SemErr("cannot assign to procedure") }
				gen.Emit(" = ")  
				Expr(&obj2)
				if obj2.type != obj.type { SemErr("incompatible types") }
				gen.Emit(obj2); gen.Emit(";"); gen.Ln() 
			} else if la.kind == 15 /* "(" */ {
				Get()
				Expect(16 /* ")" */)
				if obj.kind != .proc { SemErr("object is not a procedure") }
				gen.Emit("(void)") 
			} else { SynErr(55) }
		case _if: 
			IfStat()
		case _while: 
			WhileStat()
		case _repeat: 
			RepeatStat()
		case _switch: 
			SwitchStat()
		case _var, _let: 
			VarDecl()
		default: SynErr(56)
		}
	}

	func SimExpr(_ obj: inout Obj!) {
		var obj2: Obj! = nil; var op = Op.UNDEF 
		Term(&obj)
		while la.kind == 36 /* "-" */ || la.kind == 42 /* "+" */ || la.kind == 43 /* "|" */ {
			AddOp(&op)
			Term(&obj2)
			obj = evalConstants(obj, op, obj2) 
		}
	}

	func RelOp(_ op: inout Op) {
		op = .EQU 
		switch la.kind {
		case 44 /* "==" */: 
			Get()
		case 45 /* "<" */: 
			Get()
			op = .LSS 
		case 46 /* ">" */: 
			Get()
			op = .GTR 
		case 47 /* ">=" */: 
			Get()
			op = .GTE 
		case 48 /* "<=" */: 
			Get()
			op = .LTE 
		case 49 /* "!=" */: 
			Get()
			op = .NEQ 
		default: SynErr(57)
		}
	}

	func Term(_ obj: inout Obj!) {
		var obj2: Obj! = nil; var op = Op.UNDEF 
		Factor(&obj)
		while StartOf(3) {
			MulOp(&op)
			Factor(&obj2)
			obj = evalConstants(obj, op, obj2) 
		}
	}

	func AddOp(_ op: inout Op) {
		op = .ADD 
		if la.kind == 42 /* "+" */ {
			Get()
		} else if la.kind == 36 /* "-" */ {
			Get()
			op = .SUB 
		} else if la.kind == 43 /* "|" */ {
			Get()
			op = .OR 
		} else { SynErr(58) }
	}

	func Factor(_ obj: inout Obj!) {
		obj = nil 
		switch la.kind {
		case _ident: 
			Get()
			obj = tab.Find(t.val) 
		case _true: 
			Get()
			obj = tab.BoolCon(true) 
		case _false: 
			Get()
			obj = tab.BoolCon(false) 
		case _decInt: 
			Get()
			obj = tab.IntCon(t.val, 10) 
		case _binInt: 
			Get()
			obj = tab.IntCon(t.val, 2) 
		case _hexInt: 
			Get()
			obj = tab.IntCon(t.val, 16) 
		case _octalInt: 
			Get()
			obj = tab.IntCon(t.val, 8) 
		case _hexNumber: 
			Get()
			obj = tab.DoubleCon(t.val, 16) 
		case _decNumber: 
			Get()
			obj = tab.DoubleCon(t.val) 
		case _char: 
			Get()
			obj = tab.CharCon(t.val) 
		case _string: 
			Get()
			obj = tab.StringCon(t.val) 
		case 36 /* "-" */: 
			Get()
			Factor(&obj)
			obj = evalConstants( .NEG, obj) 
		case 37 /* "!" */: 
			Get()
			Factor(&obj)
			obj = evalConstants( .NOT, obj) 
		case 15 /* "(" */: 
			Get()
			obj = nil 
			if StartOf(4) {
				Expr(&obj)
			}
			Expect(16 /* ")" */)
		default: SynErr(59)
		}
	}

	func MulOp(_ op: inout Op) {
		op = .MUL 
		if la.kind == 38 /* "*" */ {
			Get()
		} else if la.kind == 39 /* "/" */ {
			Get()
			op = .DIV 
		} else if la.kind == 40 /* "%" */ {
			Get()
			op = .REM 
		} else if la.kind == 41 /* "&" */ {
			Get()
			op = .AND 
		} else { SynErr(60) }
	}



    public func Parse() {
        la = Token()
        la.val = ""
        Get()
		Swift2C()
		Expect(_EOF)

	}

    func set (_ x: Int, _ y: Int) -> Bool { return Parser._set[x][y] }
    static let _set: [[Bool]] = [
		[_T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x],
		[_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_x,_x],
		[_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_T,_x, _T,_T,_x,_x, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x],
		[_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x],
		[_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x]

	]
} // end Parser


public class Errors {
    public var count = 0                                 // number of errors detected
    private let errorStream = Darwin.stderr              // error messages go to this stream
    public var errMsgFormat = "-- line %i col %i: %@"    // 0=line, 1=column, 2=text
    
    func Write(_ s: String) { fputs(s, errorStream) }
    func WriteLine(_ format: String, line: Int, col: Int, s: String) {
        let str = String(format: format, line, col, s)
        WriteLine(str)
    }
    func WriteLine(_ s: String) { Write(s + "\n") }
    
    public func SynErr (_ line: Int, col: Int, n: Int) {
        var s: String
        switch n {
		case 0: s = "EOF expected"
		case 1: s = "ident expected"
		case 2: s = "hexNumber expected"
		case 3: s = "decNumber expected"
		case 4: s = "octalInt expected"
		case 5: s = "hexInt expected"
		case 6: s = "binInt expected"
		case 7: s = "decInt expected"
		case 8: s = "string expected"
		case 9: s = "char expected"
		case 10: s = "\"class\" expected"
		case 11: s = "\"{\" expected"
		case 12: s = "\";\" expected"
		case 13: s = "\"}\" expected"
		case 14: s = "\"func\" expected"
		case 15: s = "\"(\" expected"
		case 16: s = "\")\" expected"
		case 17: s = "\"Int\" expected"
		case 18: s = "\"Bool\" expected"
		case 19: s = "\"Double\" expected"
		case 20: s = "\"String\" expected"
		case 21: s = "\"Character\" expected"
		case 22: s = "\"Any\" expected"
		case 23: s = "\"var\" expected"
		case 24: s = "\"let\" expected"
		case 25: s = "\":\" expected"
		case 26: s = "\"if\" expected"
		case 27: s = "\"else\" expected"
		case 28: s = "\"while\" expected"
		case 29: s = "\"repeat\" expected"
		case 30: s = "\"case\" expected"
		case 31: s = "\"default\" expected"
		case 32: s = "\"switch\" expected"
		case 33: s = "\"=\" expected"
		case 34: s = "\"true\" expected"
		case 35: s = "\"false\" expected"
		case 36: s = "\"-\" expected"
		case 37: s = "\"!\" expected"
		case 38: s = "\"*\" expected"
		case 39: s = "\"/\" expected"
		case 40: s = "\"%\" expected"
		case 41: s = "\"&\" expected"
		case 42: s = "\"+\" expected"
		case 43: s = "\"|\" expected"
		case 44: s = "\"==\" expected"
		case 45: s = "\"<\" expected"
		case 46: s = "\">\" expected"
		case 47: s = "\">=\" expected"
		case 48: s = "\"<=\" expected"
		case 49: s = "\"!=\" expected"
		case 50: s = "??? expected"
		case 51: s = "invalid VarDecl"
		case 52: s = "invalid Type"
		case 53: s = "invalid IfStat"
		case 54: s = "invalid CaseLabel"
		case 55: s = "invalid Stat"
		case 56: s = "invalid Stat"
		case 57: s = "invalid RelOp"
		case 58: s = "invalid AddOp"
		case 59: s = "invalid Factor"
		case 60: s = "invalid MulOp"

        default: s = "error \(n)"
        }
        WriteLine(errMsgFormat, line: line, col: col, s: s)
        count += 1
	}

    public func SemErr (_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s);
        count += 1
    }
    
    public func SemErr (_ s: String) {
        WriteLine(s)
        count += 1
    }
    
    public func Warning (_ line: Int, col: Int, s: String) {
        WriteLine(errMsgFormat, line: line, col: col, s: s)
    }
    
    public func Warning(_ s: String) {
        WriteLine(s)
    }
} // Errors

